(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{577:function(t,e,a){"use strict";a.r(e);var s=a(6),v=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"react"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),a("h4",{attrs:{id:"todolist"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#todolist"}},[t._v("#")]),t._v(" todolist")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("划分：app.jsx; todoConsole.jsx; todoHeader.jsx; todoItem.jsx;  todos.js")])]),t._v(" "),a("li",[a("p",[t._v("hooks 的使用")]),t._v(" "),a("ul",[a("li",[t._v("createContext()与useContext() [管理夜间模式主题]")])]),t._v(" "),a("p",[t._v("createContext 能够创建组件间共享的上下文状态。然后通过 useContext 在组件中使用这些状态")]),t._v(" "),a("ul",[a("li",[t._v("useState, useEffect, useRef, useMemo")]),t._v(" "),a("li",[t._v("useRef：1.保存一个值,在整个生命周期中维持不变 2.重新赋值ref.current不会触发重新渲染")])])]),t._v(" "),a("li",[a("p",[t._v("自定义hook的使用")]),t._v(" "),a("ul",[a("li",[t._v("定义add，filter，switch，remove，toggle，update方法")])])]),t._v(" "),a("li",[a("p",[t._v("localStorage保存")]),t._v(" "),a("ul",[a("li",[t._v("window.localStorage.getItem")]),t._v(" "),a("li",[t._v("JSON.parse(todoData)")]),t._v(" "),a("li",[t._v('在useEffect中window.localStorage.setItem("todos", JSON.stringify(todos))【模拟DidUpdate】')])])]),t._v(" "),a("li",[a("p",[t._v("RWD:媒体查询实现响应式， MEDIA_HOVER  MEDIA_MOBILE")])])]),t._v(" "),a("p",[t._v("移动端点击事件：用"),a("code",[t._v("@media")]),t._v("将:hover伪类的内容括起来即可。从而在不能使用鼠标指针的设备上就不存在该效果")]),t._v(" "),a("h4",{attrs:{id:"five-in-a-row"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#five-in-a-row"}},[t._v("#")]),t._v(" five in a row")]),t._v(" "),a("ul",[a("li",[t._v("useRef记录上一次下棋的行与列，棋盘更新函数（useCallback缓存）")]),t._v(" "),a("li",[t._v("处理棋子点击，更新下棋记录，传入位置更新棋盘，更新player（useCallback）")]),t._v(" "),a("li",[t._v("useEffect模拟didiupdate，根据位置判定输赢")])]),t._v(" "),a("h6",{attrs:{id:"board组件与chess组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#board组件与chess组件"}},[t._v("#")]),t._v(" Board组件与Chess组件")]),t._v(" "),a("ul",[a("li",[t._v("判定输赢：\n"),a("ul",[a("li",[t._v("计算总数的函数：不同方向计算重复棋子的数目，不连续或超出棋盘跳出")]),t._v(" "),a("li",[t._v("目标左右，上下，正斜线，反斜线大于等于4，返回胜者；棋盘满平局")])])])]),t._v(" "),a("h4",{attrs:{id:"snack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#snack"}},[t._v("#")]),t._v(" snack")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("蛇移动：用复制一份蛇的尾巴通过计算位置后放在蛇头的前面（成为新的蛇头），然后删除旧的蛇尾，这就向前走了一步（重复），蛇位置｛top：0，left：0｝，移动push新蛇头，shift蛇尾。数组末尾是蛇头")])]),t._v(" "),a("li",[a("p",[t._v("随机食物位置")])]),t._v(" "),a("li",[a("p",[t._v("吃到食物加分：蛇头位置=食物位置")]),t._v(" "),a("ul",[a("li",[t._v("处理蛇身长度：吃到食物，从蛇尾（数组0位）加一截，需按照方向加值")])])]),t._v(" "),a("li",[a("p",[t._v("死亡判定：碰壁？吃自己（删除蛇头，作对比判定）")])])])])}),[],!1,null,null,null);e.default=v.exports}}]);