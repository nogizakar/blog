(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{590:function(_,v,e){"use strict";e.r(v);var t=e(6),a=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h4",{attrs:{id:"_1-模式和修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-模式和修饰符"}},[_._v("#")]),_._v(" 1.模式和修饰符")]),_._v(" "),e("ul",[e("li",[_._v("一个正则表达式包含模式和可选修饰符："),e("code",[_._v("g")]),_._v("、"),e("code",[_._v("i")]),_._v("、"),e("code",[_._v("m")]),_._v("、"),e("code",[_._v("s")]),_._v("、"),e("code",[_._v("u")]),_._v("、"),e("code",[_._v("y")]),_._v("。\n"),e("ul",[e("li",[_._v('regexp = new RegExp("pattern", "flags");')]),_._v(" "),e("li",[_._v("regexp = /pattern/; // 没有修饰符 regexp = /pattern/gmi; // 伴随修饰符 g、m 和 i")])])]),_._v(" "),e("li",[_._v("如果不使用我们在后面将要学到的修饰符和特殊标志，正则表达式的搜索就等同于子字符串查找。")]),_._v(" "),e("li",[e("code",[_._v("str.search(regexp)")]),_._v(" 方法返回的是找到的匹配项的索引位置，如果没找到则返回 "),e("code",[_._v("-1")]),_._v("。")])]),_._v(" "),e("h4",{attrs:{id:"_2-字符类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-字符类"}},[_._v("#")]),_._v(" 2.字符类")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("\\d")]),_._v(" —— 数字。")]),_._v(" "),e("li",[e("code",[_._v("\\D")]),_._v(" —— 非数字。")]),_._v(" "),e("li",[e("code",[_._v("\\s")]),_._v(" —— 空格符号，制表符，换行符。")]),_._v(" "),e("li",[e("code",[_._v("\\S")]),_._v(" —— 除了 "),e("code",[_._v("\\s")]),_._v(" 。")]),_._v(" "),e("li",[e("code",[_._v("\\w")]),_._v(" —— 拉丁字母，数字，下划线 "),e("code",[_._v("'_'")]),_._v("。")]),_._v(" "),e("li",[e("code",[_._v("\\W")]),_._v(" —— 除了 "),e("code",[_._v("\\w")]),_._v("。")]),_._v(" "),e("li",[e("code",[_._v(".")]),_._v(" —— 任何带有 "),e("code",[_._v("'s'")]),_._v(" 标志的字符，否则为除换行符 "),e("code",[_._v("\\n")]),_._v("之外的任何字符。")])]),_._v(" "),e("p",[_._v("修饰符 "),e("code",[_._v("u")]),_._v(" 在正则表达式中提供对 Unicode 的支持。")]),_._v(" "),e("p",[_._v("意味着两件事：")]),_._v(" "),e("ol",[e("li",[_._v("4 个字节长的字符被以正确的方式处理：被看成单个的字符，而不是 2 个 2 字节长的字符。")]),_._v(" "),e("li",[_._v("Unicode 属性可以被用于查找中 "),e("code",[_._v("\\p{…}")]),_._v("。")])]),_._v(" "),e("p",[_._v("有了 unicode 属性我们可以查找给定语言中的词，特殊字符（引用，货币）")]),_._v(" "),e("h4",{attrs:{id:"_3-锚点与多行模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-锚点与多行模式"}},[_._v("#")]),_._v(" 3.锚点与多行模式")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("插入符号 "),e("code",[_._v("^")]),_._v(" 匹配文本开头，而美元符号 "),e("code",[_._v("$")]),_._v(" 则匹配文本末尾")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("通过 flag "),e("code",[_._v("/.../m")]),_._v(" 可以开启多行模式。")]),_._v(" "),e("p",[_._v("这仅仅会影响 "),e("code",[_._v("^")]),_._v(" 和 "),e("code",[_._v("$")]),_._v(" 锚符的行为。")]),_._v(" "),e("p",[_._v("在多行模式下，它们不仅仅匹配文本的开始与结束，还匹配每一行的开始与结束")])])])])]),_._v(" "),e("h4",{attrs:{id:"_4-词边界-b"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-词边界-b"}},[_._v("#")]),_._v(" 4.词边界 \\b")]),_._v(" "),e("p",[_._v("会检查字符串中的位置是否是词边界")]),_._v(" "),e("p",[_._v("有三种不同的位置可作为词边界：")]),_._v(" "),e("ul",[e("li",[_._v("在字符串开头，如果第一个字符是单词字符 "),e("code",[_._v("\\w")]),_._v("。")]),_._v(" "),e("li",[_._v("在字符串中的两个字符之间，其中一个是单词字符 "),e("code",[_._v("\\w")]),_._v("，另一个不是。")]),_._v(" "),e("li",[_._v("在字符串末尾，如果最后一个字符是单词字符 "),e("code",[_._v("\\w")]),_._v("。")])]),_._v(" "),e("h4",{attrs:{id:"_5-转义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-转义"}},[_._v("#")]),_._v(" 5.转义")]),_._v(" "),e("ul",[e("li",[_._v("要在字面（意义）上搜索特殊字符 "),e("code",[_._v("[ \\ ^ $ . | ? * + ( )")]),_._v("，我们需要在它们前面加上反斜杠 "),e("code",[_._v("\\")]),_._v("（“转义它们”）。")]),_._v(" "),e("li",[_._v("如果我们在 "),e("code",[_._v("/.../")]),_._v(" 内部（但不在 "),e("code",[_._v("new RegExp")]),_._v(" 内部），还需要转义 "),e("code",[_._v("/")]),_._v("。")]),_._v(" "),e("li",[_._v("传递一个字符串（参数）给 "),e("code",[_._v("new RegExp")]),_._v(" 时，我们需要双倍反斜杠 "),e("code",[_._v("\\\\")]),_._v("，因为字符串引号会消费其中的一个")])]),_._v(" "),e("h4",{attrs:{id:"_6-集合与范围"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-集合与范围"}},[_._v("#")]),_._v(" 6.集合与范围")]),_._v(" "),e("h5",{attrs:{id:"集合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#集合"}},[_._v("#")]),_._v(" 集合")]),_._v(" "),e("p",[_._v("方括号 "),e("code",[_._v("[…]")]),_._v(" 中的几个字符或者字符类意味着“搜索给定的字符中的任意一个”，比如说，"),e("code",[_._v("[eao]")]),_._v(" 意味着查找在 3 个字符 "),e("code",[_._v("'a'")]),_._v("、"),e("code",[_._v("'e'")]),_._v(" 或者 `‘o’ 中的任意一个。")]),_._v(" "),e("h5",{attrs:{id:"范围"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#范围"}},[_._v("#")]),_._v(" 范围")]),_._v(" "),e("p",[e("code",[_._v("[a-z]")]),_._v(" 会匹配从 "),e("code",[_._v("a")]),_._v(" 到 "),e("code",[_._v("z")]),_._v(" 范围内的字母，"),e("code",[_._v("[0-5]")]),_._v(" 表示从 "),e("code",[_._v("0")]),_._v(" 到 "),e("code",[_._v("5")]),_._v(" 的数字")]),_._v(" "),e("p",[_._v("类似 "),e("code",[_._v("[^…]")]),_._v(" 的“排除”范围匹配")]),_._v(" "),e("p",[_._v("在方括号表示中，绝大多数特殊字符可以在不转义的情况下使用")]),_._v(" "),e("h4",{attrs:{id:"_7-量词-和-n"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-量词-和-n"}},[_._v("#")]),_._v(" 7.量词 "),e("code",[_._v("+,*,?")]),_._v(" 和 "),e("code",[_._v("{n}")])]),_._v(" "),e("h5",{attrs:{id:"数量-n"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数量-n"}},[_._v("#")]),_._v(" 数量｛n｝")]),_._v(" "),e("p",[_._v("确切的位数："),e("code",[_._v("{5}")])]),_._v(" "),e("p",[e("code",[_._v("\\d{5}")]),_._v(" 表示 5 位的数字，如同 "),e("code",[_._v("\\d\\d\\d\\d\\d")]),_._v("；某个范围的位数："),e("code",[_._v("{3,5}")]),_._v("。")]),_._v(" "),e("p",[_._v("省略上限，正则表达式 "),e("code",[_._v("\\d{3,}")]),_._v(" 就会查找位数大于或等于 3 的数字。")]),_._v(" "),e("h5",{attrs:{id:"缩写"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缩写"}},[_._v("#")]),_._v(" 缩写")]),_._v(" "),e("ul",[e("li",[e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("+ 代表“一个或多个”，相当于 `{1,}`\n")])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br")])])]),_._v(" "),e("li",[e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("? 代表“零个或一个”，相当于 `{0,1}`。换句话说，它使得符号变得可选\n")])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br")])])]),_._v(" "),e("li",[e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("* 代表着“零个或多个”，相当于 `{0,}`。也就是说，这个字符可以多次出现或不出现\n")])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br")])])])]),_._v(" "),e("p",[_._v("例：正则表达式“打开没有属性的HTML标记”："),e("code",[_._v("/<\\/?[a-z][a-z0-9]*>/i")])]),_._v(" "),e("h5",{attrs:{id:"贪婪和惰性量词"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#贪婪和惰性量词"}},[_._v("#")]),_._v(" 贪婪和惰性量词")]),_._v(" "),e("p",[_._v("在"),e("strong",[_._v("贪婪模式")]),_._v("下（默认情况下），量词都会尽可能地重复多次。")]),_._v(" "),e("p",[_._v("正则表达式引擎尝试用 "),e("code",[_._v(".+")]),_._v(" 去获取尽可能多的字符，然后再一步步地筛选它们。")]),_._v(" "),e("p",[e("strong",[_._v("懒惰模式")]),_._v("中的量词与贪婪模式中的是相反的。它想要“重复最少次数”，在量词之后添加一个问号 "),e("code",[_._v("'?'")]),_._v(" 来启用它。")]),_._v(" "),e("h4",{attrs:{id:"_8-捕获组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-捕获组"}},[_._v("#")]),_._v(" 8.捕获组")]),_._v(" "),e("p",[_._v("括号将正则表达式的一部分组合在一起，以便量词可以整体应用。")]),_._v(" "),e("p",[_._v("括号组从左到右编号，可以选择用 "),e("code",[_._v("(?<name>...)")]),_._v(" 命名。")]),_._v(" "),e("p",[_._v("可以在结果中获得按组匹配的内容：")]),_._v(" "),e("ul",[e("li",[_._v("方法 "),e("code",[_._v("str.match")]),_._v(" 仅当不带标志 "),e("code",[_._v("g")]),_._v(" 时返回捕获组。")]),_._v(" "),e("li",[_._v("方法 "),e("code",[_._v("str.matchAll")]),_._v(" 始终返回捕获组。")])]),_._v(" "),e("p",[_._v("如果括号没有名称，则匹配数组按编号提供其内容。命名括号还可使用属性 "),e("code",[_._v("groups")]),_._v("。")]),_._v(" "),e("p",[_._v("我们还可以使用 "),e("code",[_._v("str.replace")]),_._v(" 来替换括号内容中的字符串：使用 "),e("code",[_._v("$n")]),_._v(" 或者名称 "),e("code",[_._v("$<name>")]),_._v("。")]),_._v(" "),e("p",[_._v("可以通过在组的开头添加 "),e("code",[_._v("?:")]),_._v(" 来排除编号组。当我们需要对整个组应用量词，但不希望将其作为结果数组中的单独项时这很有用。我们也不能在替换字符串时引用此类括号。")]),_._v(" "),e("h5",{attrs:{id:"按编号反向引用-n"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#按编号反向引用-n"}},[_._v("#")]),_._v(" 按编号反向引用 \\N")]),_._v(" "),e("p",[e("code",[_._v("\\1")]),_._v(" 在模式中进一步的含义是“查找与第一（捕获）分组相同的文本”，在示例中为完全相同的引号")]),_._v(" "),e("p",[_._v("例：")]),_._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v('let str = `He said: "She\'s the one!".`;\n\n *let regexp = /([\'"])(.\\*?)\\1/g;* \n\nalert( str.match(regexp) ); // "She\'s the one!"\n')])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br"),e("span",{staticClass:"line-number"},[_._v("2")]),e("br"),e("span",{staticClass:"line-number"},[_._v("3")]),e("br"),e("span",{staticClass:"line-number"},[_._v("4")]),e("br"),e("span",{staticClass:"line-number"},[_._v("5")]),e("br")])]),e("h5",{attrs:{id:"按命名反向引用-k-name"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#按命名反向引用-k-name"}},[_._v("#")]),_._v(" 按命名反向引用 \\k <name>")]),_._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v('let str = `He said: "She\'s the one!".`; \n\n*let regexp = /(?<quote>[\'"])(.\\*?)\\k<quote>/g;*\n\n alert( str.match(regexp) ); // "She\'s the one!"\n')])]),_._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[_._v("1")]),e("br"),e("span",{staticClass:"line-number"},[_._v("2")]),e("br"),e("span",{staticClass:"line-number"},[_._v("3")]),e("br"),e("span",{staticClass:"line-number"},[_._v("4")]),e("br"),e("span",{staticClass:"line-number"},[_._v("5")]),e("br")])]),e("h4",{attrs:{id:"_9-前瞻断言和后瞻断言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-前瞻断言和后瞻断言"}},[_._v("#")]),_._v(" 9.前瞻断言和后瞻断言")]),_._v(" "),e("p",[_._v("当我们想根据前面/后面的上下文筛选出一些东西的时候，前瞻断言和后瞻断言（通常被称为“环视断言”）对于简单的正则表达式就很有用")]),_._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"left"}},[_._v("模式")]),_._v(" "),e("th",{staticStyle:{"text-align":"left"}},[_._v("类型")]),_._v(" "),e("th",{staticStyle:{"text-align":"left"}},[_._v("匹配")])])]),_._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("code",[_._v("x(?=y)")])]),_._v(" "),e("td",{staticStyle:{"text-align":"left"}},[_._v("前瞻肯定断言")]),_._v(" "),e("td",{staticStyle:{"text-align":"left"}},[e("code",[_._v("x")]),_._v(" ，仅当后面跟着 "),e("code",[_._v("y")])])]),_._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("code",[_._v("x(?!y)")])]),_._v(" "),e("td",{staticStyle:{"text-align":"left"}},[_._v("前瞻否定断言")]),_._v(" "),e("td",{staticStyle:{"text-align":"left"}},[e("code",[_._v("x")]),_._v(" ，仅当后面不跟 "),e("code",[_._v("y")])])]),_._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("code",[_._v("(?<=y)x")])]),_._v(" "),e("td",{staticStyle:{"text-align":"left"}},[_._v("后瞻肯定断言")]),_._v(" "),e("td",{staticStyle:{"text-align":"left"}},[e("code",[_._v("x")]),_._v(" ，仅当跟在 "),e("code",[_._v("y")]),_._v(" 后面")])]),_._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[e("code",[_._v("(?<!y)x")])]),_._v(" "),e("td",{staticStyle:{"text-align":"left"}},[_._v("后瞻否定断言")]),_._v(" "),e("td",{staticStyle:{"text-align":"left"}},[e("code",[_._v("x")]),_._v(" ，仅当不跟在 "),e("code",[_._v("y")]),_._v(" 后面")])])])]),_._v(" "),e("h5",{attrs:{id:"ps-灾难性回溯-catastrophic-backtracking-又译作-回溯陷阱-。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ps-灾难性回溯-catastrophic-backtracking-又译作-回溯陷阱-。"}},[_._v("#")]),_._v(" PS：“灾难性回溯（catastrophic backtracking）”，又译作“回溯陷阱”。")]),_._v(" "),e("p",[_._v("我们有 2 种处理它的思路：")]),_._v(" "),e("ul",[e("li",[_._v("重写正则表达式，尽可能减少其中排列组合的数量。")]),_._v(" "),e("li",[_._v("防止回溯（使用前瞻断言）")])]),_._v(" "),e("h4",{attrs:{id:"_10-正则表达式和字符串方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-正则表达式和字符串方法"}},[_._v("#")]),_._v(" 10.正则表达式和字符串方法")]),_._v(" "),e("p",[e("code",[_._v("str.match(regexp)")]),_._v(" 方法在字符串 "),e("code",[_._v("str")]),_._v(" 中找到匹配 "),e("code",[_._v("regexp")]),_._v(" 的字符")]),_._v(" "),e("p",[e("code",[_._v("str.matchAll(regexp)")]),_._v(" 是 "),e("code",[_._v("str.match")]),_._v(" “新改进的”变体。它主要用来搜索所有组的所有匹配项")]),_._v(" "),e("p",[_._v("str.split(regexp|substr, limit)使用正则表达式（或子字符串）作为分隔符来分割字符串")]),_._v(" "),e("p",[_._v("方法 "),e("code",[_._v("str.search(regexp)")]),_._v(" 返回第一个匹配项的位置，如果未找到，则返回 "),e("code",[_._v("-1")])]),_._v(" "),e("p",[_._v("str.replace(str|regexp, str|func)用于搜索和替换的通用方法")]),_._v(" "),e("p",[e("code",[_._v("regexp.exec(str)")]),_._v(" 方法返回字符串 "),e("code",[_._v("str")]),_._v(" 中的 "),e("code",[_._v("regexp")]),_._v(" 匹配项。与以前的方法不同，它是在正则表达式而不是字符串上调用的.")]),_._v(" "),e("p",[_._v("方法 "),e("code",[_._v("regexp.test(str)")]),_._v(" 查找匹配项，然后返回 "),e("code",[_._v("true/false")]),_._v(" 表示是否存在")])])}),[],!1,null,null,null);v.default=a.exports}}]);