(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{576:function(v,_,t){"use strict";t.r(_);var e=t(6),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说明"}},[v._v("#")]),v._v(" #说明")]),v._v(" "),t("blockquote",[t("p",[v._v("关于React与Vue的比较")])]),v._v(" "),t("h2",{attrs:{id:"_1、react与vue的区别是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、react与vue的区别是什么"}},[v._v("#")]),v._v(" 1、React与Vue的区别是什么?")]),v._v(" "),t("h3",{attrs:{id:"简答"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简答"}},[v._v("#")]),v._v(" 简答:")]),v._v(" "),t("blockquote",[t("h6",{attrs:{id:"相同点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相同点"}},[v._v("#")]),v._v(" 相同点")]),v._v(" "),t("blockquote",[t("ul",[t("li",[v._v("都有组件化思想")]),v._v(" "),t("li",[v._v("都支持服务器端渲染")]),v._v(" "),t("li",[v._v("都有 虚拟DOM")]),v._v(" "),t("li",[v._v("数据驱动视图")]),v._v(" "),t("li",[v._v("现在的数据流都是单向数据流")]),v._v(" "),t("li",[v._v("都有支持native方案: Vue的week、React的 React native")]),v._v(" "),t("li",[v._v("都有自己的构建工具: Vue的vue-cli、React的 Create React App")])])]),v._v(" "),t("h6",{attrs:{id:"区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[v._v("#")]),v._v(" 区别:")]),v._v(" "),t("blockquote",[t("ul",[t("li",[v._v("监听数据变化实现的原理不同: Vue2使用"),t("strong",[v._v("defineProperty")]),v._v("、Vue3使用"),t("strong",[v._v("Proxy")]),v._v(",而React使用的是**比较引用(diff)**实现的")]),v._v(" "),t("li",[v._v("数据变化实现的原理不同: React使用的是 "),t("strong",[v._v("不可变数据")]),v._v(" ,Vue使用的是 "),t("strong",[v._v("可变数据")])]),v._v(" "),t("li",[v._v("组件间通信方式的不同: React中我们通过 "),t("strong",[v._v("回调函数")]),v._v(" 来进行通信的 ,而Vue中 "),t("strong",[v._v("子传父")]),v._v(" 通过 "),t("strong",[v._v("事件与回调函数")]),v._v(" 两种方法")]),v._v(" "),t("li",[v._v("diff算法的不同: React中主要通过 "),t("strong",[v._v("diff")]),v._v(" 队列保存需要更新哪些DOM,得到patch树,再通过统一操作批量更新DOM; Vue中使用双向指针,边对比边更新DOM")])])])]),v._v(" "),t("h3",{attrs:{id:"i-监听数据变化的实现原理不同"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i-监听数据变化的实现原理不同"}},[v._v("#")]),v._v(" Ⅰ - 监听数据变化的实现原理不同")]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("Vue")])]),v._v(" "),t("ul",[t("li",[v._v("Vue2.x主要通过 getter、setter 以及 "),t("strong",[v._v("defineProperty")]),v._v(" 进行数据劫持,能精确知道数据变化")]),v._v(" "),t("li",[v._v("Vue3.x主要通过 "),t("strong",[v._v("Proxy")]),v._v(" 进行数据数据的劫持")])]),v._v(" "),t("p",[t("strong",[v._v("React")])]),v._v(" "),t("ul",[t("li",[v._v("React 默认是通过 比较引用("),t("strong",[v._v("diff")]),v._v(") 进行的,如果不优化可能导致大量不必要的 真实DOM 重新渲染")])]),v._v(" "),t("p",[t("strong",[v._v("为什么React不精确地进行数据变化?")])]),v._v(" "),t("blockquote",[t("ul",[t("li",[v._v("实际上这是Vue与React地设计理念上的区别:Vue使用的是"),t("code",[v._v("可变数据")]),v._v(",而React更强调数据的"),t("code",[v._v("不可变")])]),v._v(" "),t("li",[v._v("二者没用好坏之分: Vue更加简单 , 而React构建大型应用的时候更加健壮")])])])]),v._v(" "),t("h3",{attrs:{id:"ii-数据流-现在相同"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ii-数据流-现在相同"}},[v._v("#")]),v._v(" Ⅱ - 数据流 ("),t("code",[v._v("现在相同")]),v._v(")")]),v._v(" "),t("blockquote",[t("blockquote",[t("h6",{attrs:{id:"实际上在v1-x中使用的是双向数据流-但是从v2-x开始已经不鼓励组件对自己的props进行修改"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实际上在v1-x中使用的是双向数据流-但是从v2-x开始已经不鼓励组件对自己的props进行修改"}},[v._v("#")]),v._v(" "),t("strong",[v._v("实际上在V1.X中使用的是双向数据流,但是从V2.X开始已经不鼓励组件对自己的props进行修改")])])]),v._v(" "),t("p",[v._v("React中一直是单向数据流, 称之为 "),t("strong",[v._v("onChange/setState")]),v._v(" 模式.")])]),v._v(" "),t("h3",{attrs:{id:"iii-但是数据绑定不同"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#iii-但是数据绑定不同"}},[v._v("#")]),v._v(" Ⅲ - 但是数据绑定不同")]),v._v(" "),t("blockquote",[t("blockquote",[t("h6",{attrs:{id:"vue是双向绑定-而-react是单向绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue是双向绑定-而-react是单向绑定"}},[v._v("#")]),v._v(" "),t("strong",[v._v("Vue是双向绑定 而 React是单向绑定")])])]),v._v(" "),t("p",[v._v("在 "),t("strong",[v._v("Vue")]),v._v(" 中主要由三个部分组成: Model、View、 ViewModel组成. 其中 "),t("strong",[v._v("View")]),v._v(" 和 "),t("strong",[v._v("Model")]),v._v(" 不能直接进行通信, 它们通过 ViewModel 进行通信")]),v._v(" "),t("h6",{attrs:{id:"vue中"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue中"}},[v._v("#")]),v._v(" Vue中:")]),v._v(" "),t("ul",[t("li",[v._v("当 "),t("strong",[v._v("Model")]),v._v(" 部分数据发生改变时,由于Vue中的 "),t("code",[v._v("Data Binding")]),v._v(" 将底层数据和DOM进行了绑定,ViewModel 会通知 View层更新视图")]),v._v(" "),t("li",[v._v("当 视图层View 数据发生变化时也会同步更新到Model中")]),v._v(" "),t("li",[v._v("View 和 Model 之间的同步完全是自动的,不需要人为地操作DOM,所以叫双向绑定")])]),v._v(" "),t("h6",{attrs:{id:"react中"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react中"}},[v._v("#")]),v._v(" React中")]),v._v(" "),t("ul",[t("li",[v._v("react中虽然 model 和view 之间需要 setState 去手动刷新渲染 view ,所以叫单向绑定")]),v._v(" "),t("li",[v._v("React的官方文档说他是V层，这一点是对的，如果问他到底是属于MVC还是MVP还是MVVM，答案其实是他并不是任何一个,如果所有的逻辑写在组件内部，让VC和VM贴的更近，那就是MVVM")])])]),v._v(" "),t("h3",{attrs:{id:"iv-组件通信的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#iv-组件通信的区别"}},[v._v("#")]),v._v(" Ⅳ - 组件通信的区别")]),v._v(" "),t("blockquote",[t("h6",{attrs:{id:"vue中有三种方式可以实现组件通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue中有三种方式可以实现组件通信"}},[v._v("#")]),v._v(" Vue中有三种方式可以实现组件通信:")]),v._v(" "),t("ol",[t("li",[v._v("父组件通过 Props 向子组件传递数据或者回调(虽然可以,因为有双向数据绑定,所以虽然可以传回调,一般我们只传数据)")]),v._v(" "),t("li",[v._v("子组件通过 事件 向父组件发送消息")]),v._v(" "),t("li",[v._v("通过 Vue2.x 新增的 Provide/inject 来实现父组件向子组件注入数据,可以跨越多个层级")])]),v._v(" "),t("h6",{attrs:{id:"react中也有对应的三种方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react中也有对应的三种方式"}},[v._v("#")]),v._v(" React中也有对应的三种方式:")]),v._v(" "),t("ol",[t("li",[v._v("父组件可以通过 "),t("strong",[v._v("props")]),v._v(" 向子组件传递数据或者回调")]),v._v(" "),t("li",[v._v("子组件通过 "),t("strong",[v._v("回调函数")]),v._v(" 向父组件发送消息")]),v._v(" "),t("li",[v._v("可以通过 "),t("strong",[v._v("context")]),v._v(" 进行跨层的通信,这其实和 "),t("strong",[v._v("Vue中的Provide/inject")]),v._v(" 起到的作用差不多")])]),v._v(" "),t("blockquote",[t("ul",[t("li",[v._v("React 本身并不支持自定义事件,而Vue中 "),t("strong",[v._v("子传父")]),v._v(" 中传递信息有两种方式: 回调与事件")]),v._v(" "),t("li",[v._v("但VUE更倾向于使用事件,而React只能使用回调**")])])])]),v._v(" "),t("h3",{attrs:{id:"v-模板渲染方式的不同"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-模板渲染方式的不同"}},[v._v("#")]),v._v(" Ⅴ - 模板渲染方式的不同")]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("在表层上,模板的语法不同:")])]),v._v(" "),t("blockquote",[t("p",[v._v("React是通过 "),t("strong",[v._v("JSX")]),v._v(" 渲染模板,而"),t("strong",[v._v("Vue")]),v._v(" 是通过一种拓展的HTML语法进行渲染,但其实这只是表面现象,毕竟React并不依赖于"),t("strong",[v._v("JSX")]),v._v(",只能说相性好")])]),v._v(" "),t("p",[t("strong",[v._v("在深层上,模板的原理不同,这才是他们本质的区别")])]),v._v(" "),t("blockquote",[t("ul",[t("li",[v._v("React 是组件JS代码中,通过 "),t("strong",[v._v("原生JS")]),v._v(" 模板中的常见语法: 如插值、条件、循环等,更加存粹更加原生")]),v._v(" "),t("li",[v._v("而Vue是在和组件JS代码中分离的单独模板中 , "),t("strong",[v._v("通过指令来实现的")]),v._v(",如:条件语法需要用 "),t("code",[v._v("v-if")]),v._v(" 实现,这点回将HTML弄得很乱")])])]),v._v(" "),t("p",[t("strong",[v._v("举个栗子说明React这样做的好处")])]),v._v(" "),t("blockquote",[t("ul",[t("li",[v._v("React中的 "),t("strong",[v._v("render")]),v._v(" 函数是支持闭包特性的,所以我们 "),t("strong",[v._v("import")]),v._v(" 的组件在render中可以直接调用.")]),v._v(" "),t("li",[v._v("但是在Vue中,由于模板中使用的数据都必须挂载在 "),t("strong",[v._v("this")]),v._v(" 上进行一次中转,所以我们 import 一个组件之后.还需要再 "),t("strong",[v._v("components")]),v._v(" 中再声明一下,这样虽然显得很奇怪但却又是不得不这样的做法")])])])]),v._v(" "),t("h3",{attrs:{id:"vi-渲染过程-diff算法的不同-的不同"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vi-渲染过程-diff算法的不同-的不同"}},[v._v("#")]),v._v(" Ⅵ - 渲染过程(diff算法的不同)的不同")]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("Vue")]),v._v("可以更快地计算出 "),t("strong",[v._v("虚拟 DOM")]),v._v(" 的差异.这是由于它在渲染过程中会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树")]),v._v(" "),t("p",[t("strong",[v._v("React")]),v._v(" 在应用的状态被改变时,全部 "),t("strong",[v._v("子组件")]),v._v(" 全部都会重新渲染. 通过 "),t("code",[v._v("shouldComponentUpdate")]),v._v(" 这个声明周期方法可以进行控制; 但Vue将此视为默认的优化")]),v._v(" "),t("ul",[t("li",[v._v("如果应用中交互复杂,需要处理大量的UI变化,那么使用 "),t("strong",[v._v("虚拟 DOM")]),v._v(" 是一个好主意")]),v._v(" "),t("li",[v._v("但如果更新元素并不频繁,那么性能可能还不如直接操作 DOM")])])]),v._v(" "),t("h3",{attrs:{id:"vii-框架本质不同"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vii-框架本质不同"}},[v._v("#")]),v._v(" Ⅶ - 框架本质不同")]),v._v(" "),t("blockquote",[t("p",[v._v("Vue本质是 "),t("strong",[v._v("MVVM")]),v._v(" 框架,由 "),t("strong",[v._v("MVC")]),v._v(" 发展而来: "),t("strong",[v._v("最大特点双向绑定")])]),v._v(" "),t("p",[v._v("React是前端组件化框架,由后端组件化发展而来: 特点是 "),t("strong",[v._v("状态驱动视图")])]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("State")]),v._v(" --\x3e "),t("strong",[v._v("View")]),v._v(" --\x3e "),t("strong",[v._v("New State")]),v._v(" --\x3e "),t("strong",[v._v("New View")])])])]),v._v(" "),t("h3",{attrs:{id:"viii-redux-与-vuex-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#viii-redux-与-vuex-的区别"}},[v._v("#")]),v._v(" Ⅷ - Redux 与 Vuex 的区别")]),v._v(" "),t("h4",{attrs:{id:"_1-表面上"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-表面上"}},[v._v("#")]),v._v(" ① 表面上")]),v._v(" "),t("blockquote",[t("p",[v._v("从表面上说,store注入和使用方式有一些区别:")]),v._v(" "),t("ul",[t("li",[v._v("在 "),t("strong",[v._v("Vuex")]),v._v(" 中, "),t("code",[v._v("$store")]),v._v(" 被直接注入到了组件实例中,因此可以比较灵活的使用: "),t("code",[v._v("dispatch")]),v._v("、"),t("code",[v._v("commit")]),v._v("提交更新,通过"),t("code",[v._v("mapState")]),v._v(" 或者直接通过 "),t("code",[v._v("this.$store")]),v._v("来读取数据")]),v._v(" "),t("li",[v._v("在 "),t("strong",[v._v("Redux")]),v._v(" 中, 我们每一个组件都需要显式地使用"),t("code",[v._v("connect")]),v._v(" 将需要地将 "),t("code",[v._v("props")]),v._v(" 和 "),t("code",[v._v("dispatch")]),v._v(" 链接起来")]),v._v(" "),t("li",[v._v("另外,Vuex更灵活一些,组件中既可以使用"),t("code",[v._v("dispatch action")]),v._v(",也可以使用 "),t("code",[v._v("commit updates")])]),v._v(" "),t("li",[v._v("而"),t("strong",[v._v("Redux")]),v._v(" 中只能进行"),t("code",[v._v("dispacth")]),v._v(",不能直接调用 "),t("code",[v._v("reducer")]),v._v(" 进行修改")])])]),v._v(" "),t("h4",{attrs:{id:"_2-实现原理上"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-实现原理上"}},[v._v("#")]),v._v(" ② 实现原理上")]),v._v(" "),t("blockquote",[t("p",[v._v("最大的区别是两点:")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("Redux")]),v._v(" 使用的是不可变数据,而 "),t("strong",[v._v("Vuex")]),v._v(" 的数据是可变的")])]),v._v(" "),t("ul",[t("li",[v._v("因此Redux每次都是用新的 "),t("strong",[v._v("State")]),v._v(" 替换旧的 "),t("strong",[v._v("State")]),v._v(" ,而 Vuex 可以直接修改")])]),v._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[v._v("Redux在检测数据变化的时候,是通过 "),t("strong",[v._v("diff算法")]),v._v(" 进行差异比较, 而Vuex则是与Vue一样都是通过 "),t("strong",[v._v("getter/setter")]),v._v(" 来进行比较的")])]),v._v(" "),t("p",[v._v("这两点是因为React与Vue的设计理念不同")]),v._v(" "),t("blockquote",[t("ul",[t("li",[v._v("React更偏向于构建文顶大型的应用,非常的科班化")]),v._v(" "),t("li",[v._v("相比之下Vue更偏向于简单迅速地解决问题,更灵活. 也不那么严格遵循条条框框")]),v._v(" "),t("li",[v._v("因此就会给人一种大型项目用React, 小型项目用Vue的感觉")])])])]),v._v(" "),t("h2",{attrs:{id:"_2、react与vue的特点或亮点是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、react与vue的特点或亮点是什么"}},[v._v("#")]),v._v(" 2、React与Vue的特点或亮点是什么?")]),v._v(" "),t("blockquote",[t("p",[v._v("Vue作者的尤雨溪的一段话:")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("做框架的时候我们也很纠结,到底是定制内容少一点好还是定制多一点好?")])]),v._v(" "),t("li",[t("strong",[v._v("如果定制少了:很多人不知道一些情况怎么处理,所以他就乱来,代码写得乱七八糟并且性能也差,然后他就会觉得你的框架没做好")])]),v._v(" "),t("li",[t("strong",[v._v("但当大家经验越来越丰富的时候,反而会希望受到框架的限制越来越少:因为随着经验的增加,大家都知道了各种场景下应该怎么处理与优化自己的代码--\x3e限制越少,自我发挥的空间就越大!!")]),v._v("'")])]),v._v(" "),t("blockquote",[t("h6",{attrs:{id:"最终我们看到-vue的选择居于-react-与-angular-之间-框架自身的语法比-react-多些又比-angular-少一些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最终我们看到-vue的选择居于-react-与-angular-之间-框架自身的语法比-react-多些又比-angular-少一些"}},[v._v("#")]),v._v(" 最终我们看到,Vue的选择居于 "),t("strong",[v._v("React")]),v._v(" 与 "),t("strong",[v._v("angular")]),v._v(" 之间,框架自身的语法比 "),t("strong",[v._v("React")]),v._v(" 多些又比 "),t("strong",[v._v("Angular")]),v._v(" 少一些")]),v._v(" "),t("p",[v._v("正是因为选择的不同,所以呈现出来的写法与思考方式就一定会存在差异,不论优劣,肯定会导致不同的偏好,但都是能降低简化我们的开发成本")])]),v._v(" "),t("h6",{attrs:{id:"_1-react的简单在于"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-react的简单在于"}},[v._v("#")]),v._v(" 1. React的简单在于")]),v._v(" "),t("blockquote",[t("ul",[t("li",[v._v('它的核心API其实非常少.所以我们会看到很多地方说React实际上只是一个 "'),t("strong",[v._v("UI库")]),v._v('",并不是一个完整的框架.')]),v._v(" "),t("li",[v._v("他只是告诉我们 "),t("strong",[v._v("如何创建组件")]),v._v(" 以及 *"),t("em",[v._v("组件间如何进行数据传递")]),v._v(" **")]),v._v(" "),t("li",[v._v("甚至于创建组件的方式正是使用 ES6 的 class 方法(当然现在出了Hooks写法,这个暂且不论)")]),v._v(" "),t("li",[v._v("因此开发中React的使用对于 "),t("strong",[v._v("ES6")]),v._v(" 的语法依赖非常高,因为React本身就没多少强限制的语法.")]),v._v(" "),t("li",[v._v("我们只要掌握组件中的 "),t("code",[v._v("props")]),v._v("、"),t("code",[v._v("state")]),v._v("、"),t("code",[v._v("ref")]),v._v("、"),t("code",[v._v("生命周期")]),v._v(",就好像没什么其他的额外知识点,就连如果想要在jsx模板中进行遍历渲染,还得使用原生的 "),t("strong",[v._v("map")]),v._v(" 方法")]),v._v(" "),t("li",[v._v("而react的高阶组件理解后发现,其实就是JavaScript函数式编程中涉及到的思维方式")])])]),v._v(" "),t("p",[v._v("所以在我看来React最大的特点就是简单并且与原生JavaScript非常接近 --\x3e 即给开发者带来的束缚非常少,一个功能的实现,如果你知道使用原生JS怎么实现,那么你用React就能更轻松的知道怎么实现")]),v._v(" "),t("p",[t("strong",[v._v("弊端")]),v._v(":自然是当你经验缺乏时,写出来的页面性能可能非常差且有很多多余的渲染")]),v._v(" "),t("h6",{attrs:{id:"_2-vue的简单在于"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue的简单在于"}},[v._v("#")]),v._v(" 2.  Vue的简单在于")]),v._v(" "),t("blockquote",[t("ul",[t("li",[v._v("Vue提供的能力则更多一些,这些便捷的能力可以让初学者感到非常的幸福,因为很多效果只需要一些简单的代码就能实现")]),v._v(" "),t("li",[v._v("给出了很多语法糖与语法限制")]),v._v(" "),t("li",[v._v("而这些语法限制在某种程度上降低了我们的开发成本、提高了开发效率,这就是很多人认为Vue更加简单易学的原因吧")]),v._v(" "),t("li",[v._v("从学习的难易程度上来说:React之所以更难上手主要原因不是在React本身,而是它丰富的生态全,就是因为它足够简单,所以我们需要掌握的react组件就需要更多,这种情况常在我涉猎不广的时候出现,很多时候你没见过就是不知道组件可以这样使用")])])]),v._v(" "),t("p",[v._v("React已经在函数式编程的道路上走了很远,Vue也在模板渲染的道路上走了很远(vue3也支持函数式编程),没有优劣之分")]),v._v(" "),t("p",[v._v("不过我仍然更加喜欢React,但只是因为它更接近于ES6原生语法")])]),v._v(" "),t("hr"),v._v(" "),t("h2",{attrs:{id:"_3、对vue组件化的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、对vue组件化的理解"}},[v._v("#")]),v._v(" 3、对Vue组件化的理解")]),v._v(" "),t("blockquote",[t("p",[v._v("组件化是Vue的精髓,Vue应用就是用一个个组件构成的,Vue的组件化涉及到的内容非常多")]),v._v(" "),t("p",[v._v("你可以从下面几点进行阐述")])]),v._v(" "),t("h3",{attrs:{id:"i-定义与优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i-定义与优点"}},[v._v("#")]),v._v(" Ⅰ - 定义与优点")]),v._v(" "),t("blockquote",[t("ul",[t("li",[v._v("**定义:**组件是 "),t("strong",[v._v("可复用的Vue实例")]),v._v(",准确来讲它们是 "),t("code",[v._v("Vue.Component")]),v._v("的实例,继承自Vue")]),v._v(" "),t("li",[t("strong",[v._v("优点:")]),v._v(" 从上面案例可以看出组件化可以增加代码的 "),t("strong",[v._v("复用性、可维护性")]),v._v("和 "),t("strong",[v._v("可测试性")])])])]),v._v(" "),t("h3",{attrs:{id:"ii-使用场景-什么时候使用组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ii-使用场景-什么时候使用组件"}},[v._v("#")]),v._v(" Ⅱ - 使用场景(什么时候使用组件?)")]),v._v(" "),t("blockquote",[t("ul",[t("li",[t("strong",[v._v("通用组件:")]),v._v(" 实现最基础的功能,具有通用性、复用性. 如: 按钮组件、输入框组件、布局组件等")]),v._v(" "),t("li",[t("strong",[v._v("业务组件:")]),v._v(" 它们完成具体业务,具有一定的复用性. 例如: 登录组件、轮播图组件等")]),v._v(" "),t("li",[t("strong",[v._v("页面组件:")]),v._v(" 组织应用各部分独立内容,需要时再不同页面组件间切换. 如: 列表页、详情页")])])]),v._v(" "),t("h3",{attrs:{id:"iii-如何使用组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#iii-如何使用组件"}},[v._v("#")]),v._v(" Ⅲ - 如何使用组件")]),v._v(" "),t("blockquote",[t("ul",[t("li",[v._v("定义：Vue.component()，components选项，sfc")]),v._v(" "),t("li",[v._v("分类：有状态组件，functional，abstract")]),v._v(" "),t("li",[v._v("通信：props，$emit()/$on()，provide/inject，$children/$parent/$root/$attrs/$listeners")]),v._v(" "),t("li",[v._v("内容分发："),t("code",[v._v("<slot>")]),v._v("，"),t("code",[v._v("<template>")]),v._v("，v-slot")]),v._v(" "),t("li",[v._v("使用及优化：is，keep-alive，异步组件")])])]),v._v(" "),t("h3",{attrs:{id:"iv-组件的本质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#iv-组件的本质"}},[v._v("#")]),v._v(" Ⅳ - 组件的本质")]),v._v(" "),t("blockquote",[t("h6",{attrs:{id:"vue中的组件经历如下过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue中的组件经历如下过程"}},[v._v("#")]),v._v(" Vue中的组件经历如下过程")]),v._v(" "),t("p",[t("code",[v._v("组件配置(也就是我们编程的内容)")]),v._v("===Vue帮我们做的===>"),t("code",[v._v("VueComponent实例")]),v._v(" ==> "),t("code",[v._v("render()")]),v._v("  ==>"),t("code",[v._v("虚拟DOM")]),v._v(" ==>"),t("code",[v._v("dom")])]),v._v(" "),t("p",[t("strong",[v._v("所以组件的本质就是产生虚拟DOM")])])])])}),[],!1,null,null,null);_.default=a.exports}}]);