---
title: 正则表达式
date: 2021-10-21
tags:
 - Other
 - 正则
categories: 
 - Other
---


#### 1.模式和修饰符

- 一个正则表达式包含模式和可选修饰符：`g`、`i`、`m`、`s`、`u`、`y`。
  - regexp = new RegExp("pattern", "flags");
  - regexp = /pattern/; // 没有修饰符 regexp = /pattern/gmi; // 伴随修饰符 g、m 和 i
- 如果不使用我们在后面将要学到的修饰符和特殊标志，正则表达式的搜索就等同于子字符串查找。
- `str.search(regexp)` 方法返回的是找到的匹配项的索引位置，如果没找到则返回 `-1`。

#### 2.字符类

- `\d` —— 数字。
- `\D` —— 非数字。
- `\s` —— 空格符号，制表符，换行符。
- `\S` —— 除了 `\s` 。
- `\w` —— 拉丁字母，数字，下划线 `'_'`。
- `\W` —— 除了 `\w`。
- `.` —— 任何带有 `'s'` 标志的字符，否则为除换行符 `\n`之外的任何字符。

修饰符 `u` 在正则表达式中提供对 Unicode 的支持。

意味着两件事：

1. 4 个字节长的字符被以正确的方式处理：被看成单个的字符，而不是 2 个 2 字节长的字符。
2. Unicode 属性可以被用于查找中 `\p{…}`。

有了 unicode 属性我们可以查找给定语言中的词，特殊字符（引用，货币）

#### 3.锚点与多行模式

- 插入符号 `^` 匹配文本开头，而美元符号 `$` 则匹配文本末尾

  - 通过 flag `/.../m` 可以开启多行模式。

    这仅仅会影响 `^` 和 `$` 锚符的行为。

    在多行模式下，它们不仅仅匹配文本的开始与结束，还匹配每一行的开始与结束

#### 4.词边界 \b

会检查字符串中的位置是否是词边界

有三种不同的位置可作为词边界：

- 在字符串开头，如果第一个字符是单词字符 `\w`。
- 在字符串中的两个字符之间，其中一个是单词字符 `\w`，另一个不是。
- 在字符串末尾，如果最后一个字符是单词字符 `\w`。

#### 5.转义

- 要在字面（意义）上搜索特殊字符 `[ \ ^ $ . | ? * + ( )`，我们需要在它们前面加上反斜杠 `\`（“转义它们”）。
- 如果我们在 `/.../` 内部（但不在 `new RegExp` 内部），还需要转义 `/`。
- 传递一个字符串（参数）给 `new RegExp` 时，我们需要双倍反斜杠 `\\`，因为字符串引号会消费其中的一个

#### 6.集合与范围

##### 集合

方括号 `[…]` 中的几个字符或者字符类意味着“搜索给定的字符中的任意一个”，比如说，`[eao]` 意味着查找在 3 个字符 `'a'`、`'e'` 或者 `‘o’ 中的任意一个。

##### 范围

`[a-z]` 会匹配从 `a` 到 `z` 范围内的字母，`[0-5]` 表示从 `0` 到 `5` 的数字

类似 `[^…]` 的“排除”范围匹配

在方括号表示中，绝大多数特殊字符可以在不转义的情况下使用

#### 7.量词 `+,*,?` 和 `{n}`

##### 数量｛n｝

确切的位数：`{5}`

`\d{5}` 表示 5 位的数字，如同 `\d\d\d\d\d`；某个范围的位数：`{3,5}`。

省略上限，正则表达式 `\d{3,}` 就会查找位数大于或等于 3 的数字。

##### 缩写

- ```
  + 代表“一个或多个”，相当于 `{1,}`
  ```

- ```
  ? 代表“零个或一个”，相当于 `{0,1}`。换句话说，它使得符号变得可选
  ```

- ```
  * 代表着“零个或多个”，相当于 `{0,}`。也就是说，这个字符可以多次出现或不出现
  ```

例：正则表达式“打开没有属性的HTML标记”：`/<\/?[a-z][a-z0-9]*>/i`



##### 贪婪和惰性量词

在**贪婪模式**下（默认情况下），量词都会尽可能地重复多次。

正则表达式引擎尝试用 `.+` 去获取尽可能多的字符，然后再一步步地筛选它们。

**懒惰模式**中的量词与贪婪模式中的是相反的。它想要“重复最少次数”，在量词之后添加一个问号 `'?'` 来启用它。

#### 8.捕获组

括号将正则表达式的一部分组合在一起，以便量词可以整体应用。

括号组从左到右编号，可以选择用 `(?<name>...)` 命名。

可以在结果中获得按组匹配的内容：

- 方法 `str.match` 仅当不带标志 `g` 时返回捕获组。
- 方法 `str.matchAll` 始终返回捕获组。

如果括号没有名称，则匹配数组按编号提供其内容。命名括号还可使用属性 `groups`。

我们还可以使用 `str.replace` 来替换括号内容中的字符串：使用 `$n` 或者名称 `$<name>`。

可以通过在组的开头添加 `?:` 来排除编号组。当我们需要对整个组应用量词，但不希望将其作为结果数组中的单独项时这很有用。我们也不能在替换字符串时引用此类括号。



##### 按编号反向引用 \N

`\1` 在模式中进一步的含义是“查找与第一（捕获）分组相同的文本”，在示例中为完全相同的引号

例：

```
let str = `He said: "She's the one!".`;

 *let regexp = /(['"])(.\*?)\1/g;* 

alert( str.match(regexp) ); // "She's the one!"
```

##### 按命名反向引用 \k \<name>

```
let str = `He said: "She's the one!".`; 

*let regexp = /(?<quote>['"])(.\*?)\k<quote>/g;*

 alert( str.match(regexp) ); // "She's the one!"
```

#### 9.前瞻断言和后瞻断言

当我们想根据前面/后面的上下文筛选出一些东西的时候，前瞻断言和后瞻断言（通常被称为“环视断言”）对于简单的正则表达式就很有用

| 模式      | 类型         | 匹配                      |
| :-------- | :----------- | :------------------------ |
| `x(?=y)`  | 前瞻肯定断言 | `x` ，仅当后面跟着 `y`    |
| `x(?!y)`  | 前瞻否定断言 | `x` ，仅当后面不跟 `y`    |
| `(?<=y)x` | 后瞻肯定断言 | `x` ，仅当跟在 `y` 后面   |
| `(?<!y)x` | 后瞻否定断言 | `x` ，仅当不跟在 `y` 后面 |

##### PS：“灾难性回溯（catastrophic backtracking）”，又译作“回溯陷阱”。

我们有 2 种处理它的思路：

- 重写正则表达式，尽可能减少其中排列组合的数量。
- 防止回溯（使用前瞻断言）

#### 10.正则表达式和字符串方法

`str.match(regexp)` 方法在字符串 `str` 中找到匹配 `regexp` 的字符

 `str.matchAll(regexp)` 是 `str.match` “新改进的”变体。它主要用来搜索所有组的所有匹配项

str.split(regexp|substr, limit)使用正则表达式（或子字符串）作为分隔符来分割字符串

方法 `str.search(regexp)` 返回第一个匹配项的位置，如果未找到，则返回 `-1`

str.replace(str|regexp, str|func)用于搜索和替换的通用方法

`regexp.exec(str)` 方法返回字符串 `str` 中的 `regexp` 匹配项。与以前的方法不同，它是在正则表达式而不是字符串上调用的.

方法 `regexp.test(str)` 查找匹配项，然后返回 `true/false` 表示是否存在